#include "backgroundSubtract.h"
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include "opencv2/video/background_segm.hpp"
#include "ImageBasicOperations.h"
#include "opencv2/shape.hpp"
#include "ImageDB.h"


#include <iostream>

using namespace cv;
using namespace std;

Mat frame, frame2; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractorMOG2> pMOG2;
char keyboard; //input from keyboard

Mat startMotionFrame, endMotionFrame;
Mat extractedObject;
bool motionStarted = false;

/** Function Headers */
void processVideo(char *videoFilename);

void tryProcessImages(string filename, string second, string destination);

void processImages(char *firstFrameFilename);

void feedBackgroundAndGetObject();

void identifyObject();

void createPathsAndImages(string source_folder, bool createHorse);

void createDatabase();

/**
 * @function main
 */
int backgroundSubtract::startBackgroundSubtract() {

//    namedWindow("Frame");
//    namedWindow("FG Mask MOG 2");
//    pMOG2 = createBackgroundSubtractorMOG2();
//    pMOG2->setShadowValue(0);

//    processVideo((char *) "D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\videos\\vid5.mp4");
//    processImages((char *) "D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\color\\color1.bmp");
//"D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\database\\attempt2\\cal\\piece_n_00.jpg"
    //"D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\database\\attempt2\\cal\\piece_00.jpg"
    //"D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\database\\attempt2\\cal\\result_00.jpg"
//    ImageDB::createDatabase();
    ImageDB::loadSampleImages();
//    vector<Point> contour;
//    string pion = "D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\database\\regina.jpg";
//    Mat mat_pion = imread(pion, IMREAD_GRAYSCALE);
//    Size imageResizeSize(800, 600);
//
//    resize(mat_pion, mat_pion, imageResizeSize);
//
//    ImageDB::getContourFromMat(mat_pion, contour);
//
//    int distance = ImageDB::matchChessPieces(contour);
//
//    printf("Piece found:%d", distance);

//    identifyObject();
//    destroyAllWindows();
    return EXIT_SUCCESS;
}

void createDatabase() {
    string mainFolder = "attempt7";
    string pion_folder = "D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\database\\" + mainFolder + "\\pion\\";
    string tura_folder = "D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\database\\" + mainFolder + "\\tura\\";
    string nebun_folder =
            "D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\database\\" + mainFolder + "\\nebun\\";
    string rege_folder = "D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\database\\" + mainFolder + "\\rege\\";
    string regina_folder =
            "D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\database\\" + mainFolder + "\\regina\\";
    string cal_folder = "D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\database\\" + mainFolder + "\\cal\\";

//    createPathsAndImages(cal_folder, true);
//    createPathsAndImages(pion_folder, false);
//    createPathsAndImages(tura_folder, false);
//    createPathsAndImages(nebun_folder, false);
//    createPathsAndImages(rege_folder, false);
//    createPathsAndImages(regina_folder, false);
    return;
}

//Extension to create the database
//string jpg_extension = ".jpg";
//string result_format = "result_";
//string piece_format = "piece_";
//string no_piece_format = "piece_n_";

//void createPathsAndImages(string source_folder, bool createHorse) {
//    //format de nume al pieselor "piece_##" si doar background-ul "piece_n_##" si incepe de la 0
//    for (int i = 0; i < 2; i++) {
//        for (int j = 0; j < 10; j++) {
//            char number[1];
//            sprintf(number, "%d%d", i, j); //transform the int to string
//            string nr = number;
//            string source_image =
//                    source_folder + piece_format + nr + jpg_extension; // we created "folderpath\piece_##.jpg"
//            string source_n_image =
//                    source_folder + no_piece_format + nr + jpg_extension; // we created "folderpath\piece_n_##.jpg"
//            string result_image =
//                    source_folder + result_format + nr + jpg_extension; // we created "folderpath\result_##.jpg"
//            tryProcessImages(source_n_image, source_image, result_image);
//        }
//    }
//}

void countPixels(cv::Mat &src, const char *frame, vector<int> wbPixels) {
    int count_black = 0;
    int count_white = 0;
    for (int y = 0; y < src.rows; y++) {
        for (int x = 0; x < src.cols; x++) {
            if (src.at<uchar>(y, x) != 0) {
                if (src.at<cv::Vec3b>(y, x) == cv::Vec3b(255, 255, 255)) {
                    count_white++;
                } else if (src.at<cv::Vec3b>(y, x) == cv::Vec3b(0, 0, 0)) {
                    count_black++;
                }
            }
        }
    }
    wbPixels.push_back(count_white);
    wbPixels.push_back(count_black);
    printf("\n Frame (%s) has White:%d black %d", frame, count_white, count_black);
}

void simpleContour(const Mat &mat, std::vector<Point> &c) {
    vector<vector<Point>> bigcontour;


    findContours(mat, bigcontour, CV_RETR_TREE, CHAIN_APPROX_SIMPLE);

    int bigContourSize = bigcontour.size();
    for (size_t border = 0; border < bigContourSize; border++) {
        int pointSize = bigcontour[border].size();
        for (size_t point = 0; point < pointSize; point++) {
            c.push_back(bigcontour[border][point]);
        }
    }

    int n = 300; // number of ok points
    // add dummy data
    int dummy = 0;
//    for (int add = (int) c.size() - 1; add < n; add++) {
//        c.push_back(c[dummy++]);
//    }

    // Uniformly sampling
//    random_shuffle(c.begin(), c.end());
//    vector<Point> cont;
//    for (int i = 0; i < n; i++) {
//        cont.push_back(c[i]);
//    }
//    return c;
}


void identifyObject() {
    //TODO double matchShapes(InputArray contour1, InputArray contour2, int method, double parameter)
    cv::Ptr<cv::ShapeContextDistanceExtractor> mysc = cv::createShapeContextDistanceExtractor();
    Size sz2Sh(800, 600);
    string pion = "D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\database\\pion.jpg";
    string nebun = "D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\database\\nebun.jpg";
    string pion_folder =
            "D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\database\\gimp_result\\pion_";

    Mat mat_pion = imread(pion, IMREAD_GRAYSCALE);
    resize(mat_pion, mat_pion, sz2Sh);
//    imshow("QUERY", mat_pion);
    vector<Point> contQuery;
    simpleContour(mat_pion, contQuery);

    int bestMatch = 0;
    float bestDis = FLT_MAX;
    int i = 0;
    for (int j = 0; j < 10; j++) {
        printf("\n%d) ", j);
        char number[2];
        sprintf(number, "%d%d", i, j); //transform the int to string
        string nr = number;
        string stringToCompare = pion_folder + nr; // we created "folderpath\pion_##.jpg"
        Mat sample = imread(stringToCompare, 0);
        if (!(sample.cols == 0 || sample.rows == 0)) {
            resize(sample, sample, sz2Sh);
            vector<Point> contSample;
            simpleContour(sample, contSample);
            float dis = mysc->computeDistance(contQuery, contSample);
            if (dis < bestDis) {
                bestMatch = j;
                bestDis = dis;
            }
            printf("Distance: %lf", dis);
        }
    }
    printf("Best: %d", bestMatch);


}

/**
 * @function processVideo
 */
void processVideo(char *videoFilename) {
    //create the capture object
    VideoCapture capture(videoFilename);
    if (!capture.isOpened()) {
        //error in opening the video input
        cerr << "Unable to open video file: " << videoFilename << endl;
        exit(EXIT_FAILURE);
    }

    //read input data. ESC or 'q' for quitting
    keyboard = 0;
    Size size(800, 600);

    while (keyboard != 'q' && keyboard != 27) {
        //read the current frame
        if (!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }

        resize(frame, frame, size);
        GaussianBlur(frame, frame, Size(3, 3), 3.5, 3.5);

        //update the background model
        pMOG2->apply(frame, fgMaskMOG2, -1);
        //get the frame number and write it on the current frame
        stringstream ss;
        rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
                  cv::Scalar(255, 255, 255), -1);
        ss << capture.get(CAP_PROP_POS_FRAMES);
        string frameNumberString = ss.str();
//        checkMotion(fgMaskMOG2, frameNumberString.c_str());
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
        //show the current frame and the fg masks
        keyboard = (char) waitKey(1000);
        imshow("Frame", frame);
        imshow("FG Mask MOG 2", fgMaskMOG2);
        //get the input from the keyboard
    }
    //delete capture object
    capture.release();
}

/**
 * @function processImages
 */
void processImages(char *fistFrameFilename) {
    //read the first file of the sequence
    frame = imread(fistFrameFilename);
    if (frame.empty()) {
        //error in opening the first image
        cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
        exit(EXIT_FAILURE);
    }
    //current image filename
    string fn(fistFrameFilename);
    //read input data. ESC or 'q' for quitting
    keyboard = 0;
    while (keyboard != 'q' && keyboard != 27) {
        //update the background model
        pMOG2->apply(frame, fgMaskMOG2);
        //get the frame number and write it on the current frame
        size_t index = fn.find_last_of("/");
        if (index == string::npos) {
            index = fn.find_last_of("\\");
        }
        size_t index2 = fn.find_last_of(".");
        string prefix = fn.substr(0, index + 1);
        string suffix = fn.substr(index2);
        string frameNumberString = fn.substr(index + 1, index2 - index - 1);
        string frNum = "", frName = "";
        for (unsigned int i = 0; i < frameNumberString.size(); i++) {
            if (isdigit(frameNumberString.at(i))) { // Upon finding a digit, ...
                frNum += frameNumberString.at(i);
            } else { // Otherwise, move on to the next character.
                frName += frameNumberString.at(i);
            }
        }
        int frameNumber = atoi(frNum.c_str()) + 1;
        sprintf((char *) frNum.c_str(), "%d", frameNumber);
//        iss >> frameNumber;
        rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
                  cv::Scalar(255, 255, 255), -1);
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
        //show the current frame and the fg masks
        imshow("Frame", frame);
        imshow("FG Mask MOG 2", fgMaskMOG2);
        //get the input from the keyboard
        keyboard = (char) waitKey(30);
        //search for the next image in the sequence
        string nextFrameFilename = prefix + frName + frNum + suffix;
        //read the next frame
        frame = imread(nextFrameFilename);
        if (frame.empty()) {
            //error in opening the next image in the sequence
            cerr << "Unable to open image frame: " << nextFrameFilename << endl;
            exit(EXIT_FAILURE);
        }
        //update the path of the current frame
        fn.assign(nextFrameFilename);
    }
}

void tryProcessImages(string filename, string second, string destination) {
    pMOG2 = createBackgroundSubtractorMOG2();
//    pMOG2->setShadowValue(100);
    pMOG2->setDetectShadows(false);
    pMOG2->setShadowThreshold(0.9);
    printf("\n %s  ---  %s", filename.c_str(), second.c_str());
    frame = imread(filename);
    if (frame.cols == 0 || frame.rows == 0) {
        return;
    }
//    Size size(1920, 1080);
    Size size(800, 600);
    resize(frame, frame, size);
    frame = imagePreparation::blurImage(frame);
//    imshow("Frame Blur", frame);

    for (int i = 0; i < 50; i++) {
        pMOG2->apply(frame, fgMaskMOG2, 0.5);
    }

    frame2 = imread(second);
    resize(frame2, frame2, size);
    frame2 = imagePreparation::blurImage(frame2);
    imshow("Frame2 Blur", frame2);
    pMOG2->apply(frame2, fgMaskMOG2, 0);
    fgMaskMOG2 = imagePreparation::erosionImage(fgMaskMOG2, 2, 3);
    imwrite(destination, fgMaskMOG2);

//    return;
//    imshow("Frame", frame);
//    imshow("Frame2", frame2);
    imshow("FG Mask MOG 2", fgMaskMOG2);
    waitKey(600 * 10);

}