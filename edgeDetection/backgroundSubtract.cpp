//
// Created by rartin on 30/3/2017.
//

#include "backgroundSubtract.h"


/**
 * @file bg_sub.cpp
 * @brief Background subtraction tutorial sample code
 * @author Domenico D. Bloisi
 */

//opencv
#include "opencv2/imgcodecs.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/videoio.hpp"
#include <opencv2/highgui.hpp>
#include "opencv2/video/background_segm.hpp"
#include "ImageBasicOperations.h"

//C++
#include <iostream>

using namespace cv;
using namespace std;

// Global variables
Mat frame; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
//Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
Ptr<BackgroundSubtractorMOG2> pMOG2;
char keyboard; //input from keyboard

/** Function Headers */
void processVideo(char *videoFilename);
void tryProcessImages(char *filename,char *second);
void processImages(char *firstFrameFilename);

char *mog_window = (char *) "Controls";

int learningRa = -1
, backgroundRatio
, complexityReduction
, shadowThreshold
, varianceGausian
, varianceGaussianMax
, varianceGausianMin
, varianceThreshold
, varianceThreholdGen
, learningRatioAuto = 0;

double learning = -1;

int history,
        nMixtures,
        shadowValues;

int shadows;

void setLearningAuto(int, void *) {
    printf("Learnig auto changed!");
    printf("Learning auto value:%d", learningRatioAuto);
    if (learningRatioAuto == 0) {
        learning = -1;
    } else {
        learning = learningRa / 100;
    }
}

void setLearningRatio(int, void *) {
    printf("\n Learning ratio changed!");
    printf("\n New Value:%lf", (double) (learningRa / 100));
}

void setBackgroundRatio(int, void *) {
    printf("\nBackground ratio changed!");
    printf("\n Old:%lf", pMOG2->getBackgroundRatio());
    pMOG2->setBackgroundRatio(backgroundRatio / 100);
    printf(" New Value:%lf", pMOG2->getBackgroundRatio());

}

void setComplexityReduction(int, void *) {
    printf("\nComplexity Reduction changed!");
    printf("\n Old:%lf", pMOG2->getComplexityReductionThreshold());
    pMOG2->setComplexityReductionThreshold(complexityReduction / 100);
    printf(" New:%lf", pMOG2->getComplexityReductionThreshold());
}

void setShadowThreshold(int, void *) {
    printf("\nShadow threshold changed!");
    printf("\n Old:%lf", pMOG2->getShadowThreshold());
    pMOG2->setShadowThreshold(shadowThreshold / 100);
    printf(" New:%lf", pMOG2->getShadowThreshold());
}

void setGaussianViariance(int, void *) {
    printf("\nGaussian Variance changed!");
    printf("\n Old:%lf", pMOG2->getVarInit());
    pMOG2->setVarInit(varianceGausian / 100);
    printf(" New:%lf", pMOG2->getVarInit());
}

void setGaussianMaxVariance(int, void *) {
    printf("\n Gaussian Max changed!");
    printf("\n Old:%lf", pMOG2->getVarMax());
    pMOG2->setVarMax(varianceGaussianMax / 100);
    printf(" New:%lf", pMOG2->getVarMax());
}

void setGaussianMinVariance(int, void *) {
    printf("\n Gaussian Min changed!");
    printf("\n Old:%lf", pMOG2->getVarMin());
    pMOG2->setVarMin(varianceGausianMin / 100);
    printf(" New:%lf", pMOG2->getVarMin());
}

void setGaussianThreshold(int, void *) {
    printf("\n Guassian Threshold changed!");
    printf("\n Old:%lf", pMOG2->getVarThreshold());
    pMOG2->setVarThreshold(varianceThreshold / 100);
    printf(" New:%lf", pMOG2->getVarThreshold());
}

void setHistory(int, void *) {
    printf("\n History changed!");
    printf("\n Old:%d", pMOG2->getHistory());
    pMOG2->setHistory(history);
    printf(" New:%d", pMOG2->getHistory());
}

void setNMixtures(int, void *) {
    printf("\n NMixtures changed!");
    printf("\n Old:%d", pMOG2->getNMixtures());
    pMOG2->setNMixtures(nMixtures);
    printf(" New:%d", pMOG2->getNMixtures());
}

void setShadowValue(int, void *) {
    pMOG2->setShadowValue(shadowValues);
}

void setIfShowShadows(int, void *) {
    printf("\n Show shadows changed!");
    printf("\n Old:%d", pMOG2->getDetectShadows());
    pMOG2->setDetectShadows(shadows != 0);
    printf(" New:%d", pMOG2->getDetectShadows());
}

void setGaussianGen(int, void *) {
    printf("\n Gaussian gen Changed!");
    printf("\n Old:%lf", pMOG2->getVarThresholdGen());
    pMOG2->setVarThresholdGen(varianceThreholdGen / 100);
    printf(" New:%lf", pMOG2->getVarThresholdGen());
}

void createTrackbars(){
    namedWindow(mog_window);
    createTrackbar("Learning auto", mog_window, &learningRatioAuto, 1, setLearningAuto);
    createTrackbar("Learning ratio", mog_window, &learningRa, 100, setLearningRatio);
    createTrackbar("BackgroundRatio", mog_window, &backgroundRatio, 100, setBackgroundRatio);
    createTrackbar("Complexity Reduction", mog_window, &complexityReduction, 100, setComplexityReduction);
    createTrackbar("History", mog_window, &history, 100, setHistory);
    createTrackbar("NMixtures", mog_window, &nMixtures, 100, setNMixtures);
    createTrackbar("Shadow Threshold", mog_window, &shadowThreshold, 100, setShadowThreshold);
    createTrackbar("Shadow Value", mog_window, &shadowValues, 100, setShadowValue);
    createTrackbar("Shadows", mog_window, &shadows, 1, setIfShowShadows);
    createTrackbar("Variance init", mog_window, &varianceGausian, 100, setGaussianViariance);
    createTrackbar("Variance max", mog_window, &varianceGaussianMax, 100, setGaussianMaxVariance);
    createTrackbar("Variance min", mog_window, &varianceGausianMin, 100, setGaussianMinVariance);
    createTrackbar("Variance threshold", mog_window, &varianceThreshold, 100, setGaussianThreshold);
    createTrackbar("Variance gen", mog_window, &varianceThreholdGen, 100, setGaussianGen);
}

/**
 * @function main
 */
int backgroundSubtract::startBackgroundSubtract() {

    namedWindow("Frame");
    namedWindow("FG Mask MOG 2");
//    createTrackbars();
    pMOG2 = createBackgroundSubtractorMOG2();

    processVideo((char *) "D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\videos\\vid5.mp4");
//    processImages((char *) "D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\color\\color1.bmp");
//    tryProcessImages((char *) "D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\images\\background_check_1.jpg",(char *) "D:\\Facultate\\c++Project\\opencv_c-c-\\edgeDetection\\images\\background_check_3.jpg");
//    destroyAllWindows();
    return EXIT_SUCCESS;
}

void countPixels(cv::Mat &src, const char *frame) {

    int count_black = 0;
    int count_white = 0;
    for (int y = 0; y < src.rows; y++) {
        for (int x = 0; x < src.cols; x++) {
            if (src.at<uchar>(y, x) != 0) {
                if (src.at<cv::Vec3b>(y, x) == cv::Vec3b(255, 255, 255)) {
                    count_white++;
                } else if (src.at<cv::Vec3b>(y, x) == cv::Vec3b(0, 0, 0)) {
                    count_black++;
                }
            }
        }
    }

    printf("\n Frame (%s) has White:%d black %d", frame, count_white, count_black);
}

/**
 * @function processVideo
 */
void processVideo(char *videoFilename) {
    //create the capture object
    VideoCapture capture(videoFilename);
    if (!capture.isOpened()) {
        //error in opening the video input
        cerr << "Unable to open video file: " << videoFilename << endl;
        exit(EXIT_FAILURE);
    }

    //read input data. ESC or 'q' for quitting
    keyboard = 0;
    Size size(800, 600);

    while (keyboard != 'q' && keyboard != 27) {
        //read the current frame
        if (!capture.read(frame)) {
            cerr << "Unable to read next frame." << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }

        resize(frame, frame, size);
        GaussianBlur(frame, frame, Size(3, 3), 3.5, 3.5);

        //update the background model
        pMOG2->apply(frame, fgMaskMOG2, learning);
        //get the frame number and write it on the current frame
        stringstream ss;
        rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
                  cv::Scalar(255, 255, 255), -1);
        ss << capture.get(CAP_PROP_POS_FRAMES);
        string frameNumberString = ss.str();
        countPixels(fgMaskMOG2, frameNumberString.c_str());
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
        //show the current frame and the fg masks
        keyboard = (char) waitKey(1000);
        imshow("Frame", frame);
        imshow("FG Mask MOG 2", fgMaskMOG2);
        //get the input from the keyboard
    }
    //delete capture object
    capture.release();
}

/**
 * @function processImages
 */
void processImages(char *fistFrameFilename) {
    //read the first file of the sequence
    frame = imread(fistFrameFilename);
    if (frame.empty()) {
        //error in opening the first image
        cerr << "Unable to open first image frame: " << fistFrameFilename << endl;
        exit(EXIT_FAILURE);
    }
    //current image filename
    string fn(fistFrameFilename);
    //read input data. ESC or 'q' for quitting
    keyboard = 0;
    while (keyboard != 'q' && keyboard != 27) {
        //update the background model
        pMOG2->apply(frame, fgMaskMOG2);
        //get the frame number and write it on the current frame
        size_t index = fn.find_last_of("/");
        if (index == string::npos) {
            index = fn.find_last_of("\\");
        }
        size_t index2 = fn.find_last_of(".");
        string prefix = fn.substr(0, index + 1);
        string suffix = fn.substr(index2);
        string frameNumberString = fn.substr(index + 1, index2 - index - 1);
        string frNum = "", frName = "";
        for (unsigned int i = 0; i < frameNumberString.size(); i++) {
            if (isdigit(frameNumberString.at(i))) { // Upon finding a digit, ...
                frNum += frameNumberString.at(i);
            } else { // Otherwise, move on to the next character.
                frName += frameNumberString.at(i);
            }
        }
        int frameNumber = atoi(frNum.c_str()) + 1;
        sprintf((char *) frNum.c_str(), "%d", frameNumber);
//        iss >> frameNumber;
        rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
                  cv::Scalar(255, 255, 255), -1);
        putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
                FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));
        //show the current frame and the fg masks
        imshow("Frame", frame);
        imshow("FG Mask MOG 2", fgMaskMOG2);
        //get the input from the keyboard
        keyboard = (char) waitKey(30);
        //search for the next image in the sequence
        string nextFrameFilename = prefix + frName + frNum + suffix;
        //read the next frame
        frame = imread(nextFrameFilename);
        if (frame.empty()) {
            //error in opening the next image in the sequence
            cerr << "Unable to open image frame: " << nextFrameFilename << endl;
            exit(EXIT_FAILURE);
        }
        //update the path of the current frame
        fn.assign(nextFrameFilename);
    }
}

void tryProcessImages(char *filename,char *second){
    frame = imread(filename);
    Size size(800, 600);
    resize(frame,frame,size);

    for(int i=0;i<20;i++){
        pMOG2->apply(frame,fgMaskMOG2,0.5);
    }

    Mat frame2=imread(second);
    resize(frame2,frame2,size);
    pMOG2->apply(frame2,fgMaskMOG2,0);
    fgMaskMOG2=imagePreparation::erosionImage(fgMaskMOG2, 2, 3);

    imshow("Frame", frame);
    imshow("Frame2", frame2);
    imshow("FG Mask MOG 2", fgMaskMOG2);
}